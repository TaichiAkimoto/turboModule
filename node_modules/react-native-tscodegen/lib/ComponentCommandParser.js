"use strict";
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", { value: true });
exports.parseCommands = void 0;
var ts = require("typescript");
var ExportParser_1 = require("./ExportParser");
var TypeChecker_1 = require("./TypeChecker");
function typeNodeToCommandsTypeAnnotation(typeNode, sourceFile) {
    var rawType = TypeChecker_1.typeToRNRawType(typeNode, sourceFile, { allowObject: false });
    switch (rawType.kind) {
        case 'String': return { type: 'StringTypeAnnotation' };
        case 'Float': return { type: 'FloatTypeAnnotation' };
        case 'Double': return { type: 'DoubleTypeAnnotation' };
        case 'Int32': return { type: 'Int32TypeAnnotation' };
        case 'Boolean': return { type: 'BooleanTypeAnnotation' };
        case 'rn:RootTag': return { type: 'ReservedTypeAnnotation', name: 'RootTag' };
        default:
    }
    throw new Error("Component command argument type does not support " + typeNode.getText() + ": " + JSON.stringify(rawType, undefined, 2) + ".");
}
function parseCommands(info) {
    if (info === undefined) {
        return [];
    }
    var validMembers = ExportParser_1.getMembersFromType(info.typeNode, info.sourceFile);
    if (validMembers === undefined) {
        throw new Error("Type " + info.typeNode.getText() + " to define commands should be a interface type defined in the same source file.");
    }
    function getMember(name) {
        for (var _i = 0, _a = validMembers; _i < _a.length; _i++) {
            var member = _a[_i];
            if (member.name !== undefined && member.name.getText() === name) {
                return member;
            }
        }
        return undefined;
    }
    var commands = [];
    var _loop_1 = function (commandName) {
        var decl = getMember(commandName);
        if (decl === undefined) {
            throw new Error("Unable to find command " + commandName + " in type " + info.typeNode.getText() + ".");
        }
        var funcDecl = void 0;
        var funcReturnType = void 0;
        var funcParameters = void 0;
        if (ts.isMethodSignature(decl) || ts.isCallSignatureDeclaration(decl)) {
            if (decl.typeParameters !== undefined && decl.typeParameters.length !== 0) {
                throw new Error("Command " + commandName + " in type " + info.typeNode.getText() + " should not be generic.");
            }
            if (decl.type === undefined) {
                throw new Error("Command " + commandName + " in type " + info.typeNode.getText() + " should have a return type.");
            }
            funcDecl = decl;
            funcReturnType = decl.type;
            funcParameters = decl.parameters;
        }
        else if (ts.isPropertySignature(decl) || ts.isPropertyDeclaration(decl)) {
            if (decl.type === undefined) {
                throw new Error("Command " + commandName + " in type " + info.typeNode.getText() + " should have a property type.");
            }
            var propType = ExportParser_1.resolveType(decl.type, info.sourceFile);
            if (ts.isFunctionTypeNode(propType)) {
                if (propType.typeParameters !== undefined && propType.typeParameters.length !== 0) {
                    throw new Error("Command " + commandName + " in type " + info.typeNode.getText() + " should not be generic.");
                }
                funcDecl = decl;
                funcReturnType = propType.type;
                funcParameters = propType.parameters;
            }
        }
        if (funcDecl === undefined || funcReturnType === undefined || funcParameters === undefined) {
            throw new Error("Command " + commandName + " in type " + info.typeNode.getText() + " should be a function.");
        }
        if (ExportParser_1.resolveType(funcReturnType, info.sourceFile).kind !== ts.SyntaxKind.VoidKeyword) {
            console.log(funcReturnType.kind);
            throw new Error("Command " + commandName + " in type " + info.typeNode.getText() + " should return void.");
        }
        if (funcParameters.length === 0) {
            throw new Error("Command " + commandName + " in type " + info.typeNode.getText() + " should have at least one parameter.");
        }
        var viewRefType = funcParameters[0].type;
        if (viewRefType === undefined || !ts.isTypeReferenceNode(viewRefType) || (viewRefType.typeName.getText() !== 'React.Ref' &&
            viewRefType.typeName.getText() !== 'React.ElementRef' &&
            (viewRefType.typeArguments === undefined ||
                viewRefType.typeArguments.length !== 1))) {
            throw new Error("The first parameter in command " + commandName + " in type " + info.typeNode.getText() + " should be React.Ref<'NAME'> or React.ElementRef<TYPE>.");
        }
        commands.push({
            name: commandName,
            optional: funcDecl.questionToken !== undefined,
            typeAnnotation: {
                type: 'FunctionTypeAnnotation',
                returnTypeAnnotation: { type: 'VoidTypeAnnotation' },
                params: funcParameters.slice(1).map(function (param) {
                    if (param.type === undefined) {
                        throw new Error("Parameter " + param.name.getText() + " in command " + commandName + " in type " + info.typeNode.getText() + " should have a parameter type.");
                    }
                    // provided test case fixtures miss the "optional" field
                    var commandParam = {
                        name: param.name.getText(),
                        typeAnnotation: typeNodeToCommandsTypeAnnotation(param.type, info.sourceFile)
                    };
                    return commandParam;
                })
            }
        });
    };
    for (var _i = 0, _a = info.supportedCommands; _i < _a.length; _i++) {
        var commandName = _a[_i];
        _loop_1(commandName);
    }
    return commands;
}
exports.parseCommands = parseCommands;
//# sourceMappingURL=ComponentCommandParser.js.map