"use strict";
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", { value: true });
exports.processNativeModule = void 0;
var TypeChecker_1 = require("./TypeChecker");
function rawTypeToBaseType(rawType, usedAliases) {
    switch (rawType.kind) {
        case 'String': return { type: 'StringTypeAnnotation' };
        case 'Number': return { type: 'NumberTypeAnnotation' };
        case 'Int32': return { type: 'Int32TypeAnnotation' };
        case 'Float': return { type: 'FloatTypeAnnotation' };
        case 'Double': return { type: 'DoubleTypeAnnotation' };
        case 'Boolean': return { type: 'BooleanTypeAnnotation' };
        case 'js:Object': return { type: 'GenericObjectTypeAnnotation' };
        case 'rn:RootTag': return { type: 'ReservedTypeAnnotation', name: 'RootTag' };
        case 'rn:UnsafeObject': return { type: 'GenericObjectTypeAnnotation' };
        case 'Array': {
            if (rawType.elementType.kind === 'Union' || rawType.elementType.kind === 'Tuple' || rawType.elementType.kind === 'Any') {
                return { type: 'ArrayTypeAnnotation' };
            }
            else {
                return { type: 'ArrayTypeAnnotation', elementType: rawTypeToBaseType(rawType.elementType, usedAliases) };
            }
        }
        case 'Object': return {
            type: 'ObjectTypeAnnotation',
            properties: rawType.properties.map(function (param) {
                var propertyType = rawTypeToBaseType(param.propertyType, usedAliases);
                return {
                    optional: param.optional,
                    name: param.name,
                    typeAnnotation: param.propertyType.isNullable ? { type: 'NullableTypeAnnotation', typeAnnotation: propertyType } : propertyType
                };
            })
        };
        case 'Alias': {
            usedAliases.push(rawType.name);
            return {
                type: 'TypeAliasTypeAnnotation',
                name: rawType.name
            };
        }
        default:
    }
    if (rawType.kind === 'Union' || rawType.kind === 'Tuple') {
        throw new Error(rawType.kind + " is only allowed in arrays in native module.");
    }
    else {
        throw new Error(rawType.kind + " is not supported in native module.");
    }
}
function rawTypeToParamType(rawType, usedAliases) {
    switch (rawType.kind) {
        case 'Function': return {
            type: 'FunctionTypeAnnotation',
            params: rawType.parameters.map(function (param) {
                var parameterType = rawTypeToParamType(param.parameterType, usedAliases);
                return {
                    optional: param.optional,
                    name: param.name,
                    typeAnnotation: param.parameterType.isNullable ? { type: 'NullableTypeAnnotation', typeAnnotation: parameterType } : parameterType
                };
            }),
            returnTypeAnnotation: rawTypeToReturnType(rawType.returnType, usedAliases)
        };
        default:
            return rawTypeToBaseType(rawType, usedAliases);
    }
}
function rawTypeToReturnType(rawType, usedAliases) {
    switch (rawType.kind) {
        case 'String': return { type: 'StringTypeAnnotation' };
        case 'Number': return { type: 'NumberTypeAnnotation' };
        case 'Int32': return { type: 'Int32TypeAnnotation' };
        case 'Float': return { type: 'FloatTypeAnnotation' };
        case 'Double': return { type: 'DoubleTypeAnnotation' };
        case 'Boolean': return { type: 'BooleanTypeAnnotation' };
        case 'js:Object': return { type: 'GenericObjectTypeAnnotation' };
        case 'rn:RootTag': return { type: 'ReservedTypeAnnotation', name: 'RootTag' };
        case 'rn:UnsafeObject': return { type: 'GenericObjectTypeAnnotation' };
        case 'Void':
        case 'Null': return { type: 'VoidTypeAnnotation' };
        case 'Array': {
            if (rawType.elementType.kind === 'Union' || rawType.elementType.kind === 'Tuple' || rawType.elementType.kind === 'Any') {
                return { type: 'ArrayTypeAnnotation' };
            }
            else {
                return { type: 'ArrayTypeAnnotation', elementType: rawTypeToBaseType(rawType.elementType, usedAliases) };
            }
        }
        // What happened?
        // case 'js:Promise': return { type: 'GenericPromiseTypeAnnotation', nullable: rawType.isNullable, resolvedType: rawTypeToReturnType(rawType.elementType) };
        case 'js:Promise': return { type: 'PromiseTypeAnnotation' };
        case 'Object': return {
            type: 'ObjectTypeAnnotation',
            properties: rawType.properties.map(function (param) {
                return {
                    optional: param.propertyType.isNullable,
                    name: param.name,
                    typeAnnotation: rawTypeToBaseType(param.propertyType, usedAliases)
                };
            })
        };
        case 'Alias': {
            usedAliases.push(rawType.name);
            return {
                type: 'TypeAliasTypeAnnotation',
                name: rawType.name
            };
        }
        default:
    }
    if (rawType.kind === 'Union' || rawType.kind === 'Tuple') {
        throw new Error(rawType.kind + " is only allowed in arrays in native module.");
    }
    else {
        throw new Error(rawType.kind + " is not supported in native module.");
    }
}
function processNativeModule(info, nativeModuleAliases) {
    var rawType = TypeChecker_1.typeToRNRawType(info.typeNode, info.sourceFile, { allowObject: true, knownAliases: Object.keys(nativeModuleAliases.aliases) });
    if (rawType.kind !== 'Object') {
        throw new Error("An object type is expected as a native module: " + info.typeNode.getText() + ".");
    }
    var properties = [];
    var usedAliases = [];
    for (var _i = 0, _a = rawType.properties; _i < _a.length; _i++) {
        var prop = _a[_i];
        if (prop.name === 'getConstants' &&
            prop.propertyType.isNullable === true &&
            prop.propertyType.kind === 'Function' &&
            prop.propertyType.parameters.length === 0 &&
            prop.propertyType.returnType.kind === 'Object' &&
            prop.propertyType.returnType.properties.length === 0) {
            // this function is from TurboModule
            continue;
        }
        if (prop.propertyType.kind !== 'Function') {
            throw new Error("Member " + prop.name + " in a native module type " + info.typeNode.getText() + " is expected to be a function.");
        }
        properties.push({
            name: prop.name,
            optional: prop.optional,
            typeAnnotation: rawTypeToParamType(prop.propertyType, usedAliases)
        });
    }
    var aliases = {};
    var writableAliases = aliases;
    Object.keys(nativeModuleAliases.aliases).forEach(function (key) {
        var rnRawType = nativeModuleAliases.aliases[key];
        if (rnRawType !== undefined) {
            writableAliases[key] = rawTypeToParamType(rnRawType, usedAliases);
        }
    });
    Object.keys(nativeModuleAliases.aliases).forEach(function (key) {
        if (usedAliases.indexOf(key) === -1) {
            delete writableAliases[key];
        }
    });
    var spec = { properties: properties };
    var moduleNames = [info.name];
    var excludedPlatforms = [];
    if (info.name.endsWith('Android')) {
        excludedPlatforms.push('iOS');
    }
    if (info.name.endsWith('IOS')) {
        excludedPlatforms.push('android');
    }
    if (excludedPlatforms.length === 0) {
        return { type: 'NativeModule', aliases: aliases, spec: spec, moduleNames: moduleNames };
    }
    else {
        return { type: 'NativeModule', aliases: aliases, spec: spec, moduleNames: moduleNames, excludedPlatforms: excludedPlatforms };
    }
}
exports.processNativeModule = processNativeModule;
//# sourceMappingURL=NativeModuleParser.js.map