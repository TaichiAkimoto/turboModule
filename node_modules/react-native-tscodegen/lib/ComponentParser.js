"use strict";
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", { value: true });
exports.processComponent = void 0;
var ts = require("typescript");
var ComponentCommandParser_1 = require("./ComponentCommandParser");
var ComponentEventParser_1 = require("./ComponentEventParser");
var ComponentPropertyParser_1 = require("./ComponentPropertyParser");
var ExportParser_1 = require("./ExportParser");
function importExists(sourceFile, name) {
    var result = sourceFile.forEachChild(function (importNode) {
        if (ts.isImportDeclaration(importNode)) {
            if (importNode.importClause !== undefined) {
                if (importNode.importClause.name !== undefined) {
                    if (importNode.importClause.name.getText() === name) {
                        return true;
                    }
                }
                if (importNode.importClause.namedBindings !== undefined && ts.isNamedImports(importNode.importClause.namedBindings)) {
                    for (var _i = 0, _a = importNode.importClause.namedBindings.elements; _i < _a.length; _i++) {
                        var specifier = _a[_i];
                        if (specifier.name.getText() === name) {
                            return true;
                        }
                    }
                }
            }
            return undefined;
        }
    });
    return result === undefined ? false : result;
}
function processComponent(info, commandsInfo) {
    var _a;
    var extendsProps = [];
    var events = [];
    var props = [];
    var commands = [];
    commands = ComponentCommandParser_1.parseCommands(commandsInfo);
    var validMembers = ExportParser_1.getMembersFromType(info.typeNode, info.sourceFile);
    if (validMembers === undefined) {
        throw new Error("Type " + info.typeNode.getText() + " to define a component should be a interface type defined in the same source file.");
    }
    for (var _i = 0, validMembers_1 = validMembers; _i < validMembers_1.length; _i++) {
        var propDecl = validMembers_1[_i];
        if (propDecl.name !== undefined) {
            var propertyName = propDecl.name.getText();
            if (ts.isPropertySignature(propDecl) || ts.isPropertyDeclaration(propDecl)) {
                var eventInfo = ComponentEventParser_1.checkEventType(propDecl.type, info, propDecl);
                if (eventInfo === undefined) {
                    props.push(ComponentPropertyParser_1.parseProperty(info, propDecl));
                }
                else {
                    events.push(ComponentEventParser_1.parseEvent(info, propDecl, eventInfo));
                }
            }
            else {
                throw new Error("Member " + propertyName + " in type " + info.typeNode.getText() + " is expected to be a property.");
            }
        }
    }
    if (importExists(info.sourceFile, 'ViewProps')) {
        extendsProps.push({ knownTypeName: 'ReactNativeCoreViewProps', type: 'ReactNativeBuiltInType' });
    }
    var shape = {
        extendsProps: extendsProps,
        events: events,
        props: props,
        commands: commands
    };
    Object.getOwnPropertyNames(info.options).forEach(function (key) {
        shape[key] = info.options[key];
    });
    return { type: 'Component', components: (_a = {}, _a[info.name] = shape, _a) };
}
exports.processComponent = processComponent;
//# sourceMappingURL=ComponentParser.js.map