"use strict";
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", { value: true });
exports.tryParseExportCommand = exports.tryParseExportComponent = exports.tryParseExportNativeModule = exports.tryParseExport = exports.tryParseExportedCallExpression = exports.getMembersFromType = exports.resolveType = void 0;
var ts = require("typescript");
function resolveType(typeNode, sourceFile) {
    if (ts.isParenthesizedTypeNode(typeNode)) {
        return typeNode.type;
    }
    else if (ts.isTypeReferenceNode(typeNode)) {
        if (typeNode.typeArguments === undefined || typeNode.typeArguments.length === 0) {
            for (var _i = 0, _a = sourceFile.statements; _i < _a.length; _i++) {
                var stat = _a[_i];
                if (ts.isTypeAliasDeclaration(stat) && stat.name.getText() === typeNode.typeName.getText()) {
                    return resolveType(stat.type, sourceFile);
                }
            }
        }
    }
    return typeNode;
}
exports.resolveType = resolveType;
function getMembersFromType(typeNode, sourceFile) {
    if (ts.isParenthesizedTypeNode(typeNode)) {
        return getMembersFromType(typeNode.type, sourceFile);
    }
    else if (ts.isTypeLiteralNode(typeNode)) {
        return typeNode.members;
    }
    else if (ts.isIntersectionTypeNode(typeNode)) {
        var validMembers = typeNode.types
            .map(function (itemType) { return getMembersFromType(itemType, sourceFile); })
            .filter(function (members) { return members !== undefined; });
        if (validMembers.length === 0) {
            return undefined;
        }
        else {
            return validMembers.reduce(function (a, b) { return a.concat(b); });
        }
    }
    else if (ts.isTypeReferenceNode(typeNode)) {
        switch (typeNode.typeName.getText()) {
            case 'Readonly': {
                if (typeNode.typeArguments !== undefined && typeNode.typeArguments.length > 0) {
                    return getMembersFromType(typeNode.typeArguments[0], sourceFile);
                }
                break;
            }
            case 'ViewProps': return undefined;
            default: {
                for (var _i = 0, _a = sourceFile.statements; _i < _a.length; _i++) {
                    var stat = _a[_i];
                    if (ts.isInterfaceDeclaration(stat) && stat.name.getText() === typeNode.typeName.getText()) {
                        return stat.members;
                    }
                    else if (ts.isTypeAliasDeclaration(stat) && stat.name.getText() === typeNode.typeName.getText()) {
                        return getMembersFromType(stat.type, sourceFile);
                    }
                }
            }
        }
    }
    return undefined;
}
exports.getMembersFromType = getMembersFromType;
function tryParseExportedCallExpression(callExpression, functionName) {
    // the export statement may be "export default (CALL-EXPRESSION as Type)"
    while (ts.isParenthesizedExpression(callExpression) || ts.isTypeAssertion(callExpression) || ts.isAsExpression(callExpression)) {
        // tslint:disable-next-line:no-parameter-reassignment
        callExpression = callExpression.expression;
    }
    // ensure that the export statement is exporting the result of a function call to the specified function
    if (!ts.isCallExpression(callExpression)) {
        return undefined;
    }
    if (ts.isIdentifier(callExpression.expression)) {
        if (callExpression.expression.text !== functionName) {
            return undefined;
        }
    }
    else if (ts.isQualifiedName(callExpression.expression)) {
        if (callExpression.expression.getText() !== functionName) {
            return undefined;
        }
    }
    else if (ts.isPropertyAccessExpression(callExpression.expression)) {
        if (callExpression.expression.getText() !== functionName) {
            return undefined;
        }
    }
    else {
        return undefined;
    }
    if (callExpression.typeArguments === undefined || callExpression.typeArguments.length !== 1) {
        throw new Error("The call to function " + functionName + " should have one type argument.");
    }
    if (!ts.isTypeNode(callExpression.typeArguments[0])) {
        throw new Error("The call to function " + functionName + " should have one type argument.");
    }
    if (callExpression.arguments.length === 0) {
        throw new Error("The call to function " + functionName + " should have one at least one argument.");
    }
    return [callExpression.typeArguments[0], callExpression.arguments[0], callExpression.arguments[1]];
}
exports.tryParseExportedCallExpression = tryParseExportedCallExpression;
function tryParseExport(program, sourceFile, node, functionName) {
    // export default FUNCTION_NAME<TYPE>(ARGUMENT)
    // export something = FUNCTION_NAME<TYPE>(ARGUMENT)
    if (ts.isExportAssignment(node)) {
        if (node.isExportEquals !== undefined && node.isExportEquals) {
            // unexpected: export = something;
            return undefined;
        }
        return tryParseExportedCallExpression(node.expression, functionName);
    }
    else if (ts.isVariableStatement(node)) {
        // unexpected: unexported variable declaration
        var typeChecker = program.getTypeChecker();
        var exportSymbols = typeChecker.getExportsOfModule(typeChecker.getSymbolAtLocation(sourceFile));
        for (var _i = 0, _a = node.declarationList.declarations; _i < _a.length; _i++) {
            var varDecl = _a[_i];
            if (varDecl.initializer !== undefined) {
                var exportedSymbol = typeChecker.getSymbolAtLocation(varDecl.name);
                if (exportSymbols.indexOf(exportedSymbol) !== -1) {
                    var exportInfo = tryParseExportedCallExpression(varDecl.initializer, functionName);
                    if (exportInfo !== undefined) {
                        if (node.declarationList.declarations.length !== 1) {
                            throw new Error("The call of function " + functionName + " should be exported independently.");
                        }
                        return exportInfo;
                    }
                }
            }
        }
        return undefined;
    }
    else {
        return undefined;
    }
}
exports.tryParseExport = tryParseExport;
function tryParseExportNativeModule(program, sourceFile, node) {
    var exportInfo = tryParseExport(program, sourceFile, node, 'TurboModuleRegistry.getEnforcing');
    if (exportInfo === undefined) {
        return undefined;
    }
    var typeNode = exportInfo[0], moduleNameNode = exportInfo[1];
    if (!ts.isStringLiteral(moduleNameNode)) {
        return undefined;
    }
    return {
        program: program,
        sourceFile: sourceFile,
        name: moduleNameNode.text,
        typeNode: typeNode
    };
}
exports.tryParseExportNativeModule = tryParseExportNativeModule;
function tryParseExportComponent(program, sourceFile, node) {
    var exportInfo = tryParseExport(program, sourceFile, node, 'codegenNativeComponent');
    if (exportInfo === undefined) {
        return undefined;
    }
    var typeNode = exportInfo[0], componentNameNode = exportInfo[1], optionsNode = exportInfo[2];
    if (!ts.isStringLiteral(componentNameNode)) {
        return undefined;
    }
    var result = {
        program: program,
        sourceFile: sourceFile,
        typeNode: typeNode,
        name: componentNameNode.text,
        options: {}
    };
    if (optionsNode !== undefined && ts.isObjectLiteralExpression(optionsNode)) {
        optionsNode.properties.forEach(function (optionItem) {
            if (ts.isPropertyAssignment(optionItem) && optionItem.initializer !== undefined) {
                if (ts.isStringLiteral(optionItem.initializer)) {
                    result.options[optionItem.name.getText()] = optionItem.initializer.text;
                }
                else if (optionItem.initializer.kind === ts.SyntaxKind.TrueKeyword) {
                    result.options[optionItem.name.getText()] = true;
                }
                else if (optionItem.initializer.kind === ts.SyntaxKind.FalseKeyword) {
                    result.options[optionItem.name.getText()] = false;
                }
                else if (ts.isArrayLiteralExpression(optionItem.initializer)) {
                    var strings = [];
                    for (var _i = 0, _a = optionItem.initializer.elements; _i < _a.length; _i++) {
                        var element = _a[_i];
                        if (ts.isStringLiteral(element)) {
                            strings.push(element.text);
                        }
                    }
                    result.options[optionItem.name.getText()] = strings;
                }
            }
        });
    }
    return result;
}
exports.tryParseExportComponent = tryParseExportComponent;
function tryParseExportCommand(program, sourceFile, node) {
    var exportInfo = tryParseExport(program, sourceFile, node, 'codegenNativeCommands');
    if (exportInfo === undefined) {
        return undefined;
    }
    var typeNode = exportInfo[0], componentNameNode = exportInfo[1];
    var commandNameError = new Error("The first argument to codegenNativeCommands is expected to be {supportedCommands:ARRAY-OF-STRING-LITERALS}, instead of " + componentNameNode.getText() + ".");
    if (!ts.isObjectLiteralExpression(componentNameNode)) {
        throw commandNameError;
    }
    if (componentNameNode.properties.length !== 1) {
        throw commandNameError;
    }
    var commandNameProp = componentNameNode.properties[0];
    if (!ts.isPropertyAssignment(commandNameProp)) {
        throw commandNameError;
    }
    if (!ts.isIdentifier(commandNameProp.name) && !ts.isStringLiteral(commandNameProp.name)) {
        throw commandNameError;
    }
    if (commandNameProp.name.text !== 'supportedCommands') {
        throw commandNameError;
    }
    var commandNameArray = commandNameProp.initializer;
    if (!ts.isArrayLiteralExpression(commandNameArray)) {
        throw commandNameError;
    }
    return {
        program: program,
        sourceFile: sourceFile,
        typeNode: typeNode,
        supportedCommands: commandNameArray.elements.map(function (value) {
            if (!ts.isStringLiteral(value)) {
                throw commandNameError;
            }
            return value.text;
        })
    };
}
exports.tryParseExportCommand = tryParseExportCommand;
//# sourceMappingURL=ExportParser.js.map