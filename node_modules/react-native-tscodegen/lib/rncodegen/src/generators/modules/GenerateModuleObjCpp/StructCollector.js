/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 *       strict
 * @format
 */

'use strict';

             
           
                                   
                                   
                                   
                                  
                                   
                                  
                                    
                                          
                         
                                      
                                  
                                 
                                

                                            

const {capitalize} = require('../../Utils');
const {
  unwrapNullable,
  wrapNullable,
} = require('../../../parsers/flow/modules/utils');

                                             

                                       
                     
               
                                             
   

                                         
                       
               
                                             
   

                                                     

                                        
               
                    
                                                 
   

                                  
                                    
                                    
                                   
                                    
                                   
                                     
                                           
                          
                                       
                                                                    

class StructCollector {
  _structs                      = new Map();

  process(
    structName        ,
    structContext               ,
    resolveAlias               ,
    nullableTypeAnnotation                                          ,
  )                                 {
    const [typeAnnotation, nullable] = unwrapNullable(nullableTypeAnnotation);
    switch (typeAnnotation.type) {
      case 'ObjectTypeAnnotation': {
        this._insertStruct(
          structName,
          structContext,
          resolveAlias,
          typeAnnotation,
        );
        return wrapNullable(nullable, {
          type: 'TypeAliasTypeAnnotation',
          name: structName,
        });
      }
      case 'ArrayTypeAnnotation': {
        if (typeAnnotation.elementType == null) {
          return wrapNullable(nullable, {
            type: 'ArrayTypeAnnotation',
          });
        }

        return wrapNullable(nullable, {
          type: 'ArrayTypeAnnotation',
          elementType: this.process(
            structName + 'Element',
            structContext,
            resolveAlias,
            typeAnnotation.elementType,
          ),
        });
      }
      case 'TypeAliasTypeAnnotation': {
        this._insertAlias(typeAnnotation.name, structContext, resolveAlias);
        return wrapNullable(nullable, typeAnnotation);
      }
      default: {
        return wrapNullable(nullable, typeAnnotation);
      }
    }
  }

  _insertAlias(
    aliasName        ,
    structContext               ,
    resolveAlias               ,
  )       {
    const usedStruct = this._structs.get(aliasName);
    if (usedStruct == null) {
      this._insertStruct(
        aliasName,
        structContext,
        resolveAlias,
        resolveAlias(aliasName),
      );
    } else if (usedStruct.context !== structContext) {
      throw new Error(
        `Tried to use alias '${aliasName}' in a getConstants() return type and inside a regular struct.`,
      );
    }
  }

  _insertStruct(
    structName        ,
    structContext               ,
    resolveAlias               ,
    objectTypeAnnotation                                  ,
  )       {
    // $FlowFixMe[missing-type-arg]
    const properties = objectTypeAnnotation.properties.map 
                 
                     
                          
                                                       
         
     (property => {
      const propertyStructName = structName + capitalize(property.name);

      return {
        ...property,
        typeAnnotation: this.process(
          propertyStructName,
          structContext,
          resolveAlias,
          property.typeAnnotation,
        ),
      };
    });

    switch (structContext) {
      case 'REGULAR':
        this._structs.set(structName, {
          name: structName,
          context: 'REGULAR',
          properties: properties,
        });
        break;
      case 'CONSTANTS':
        this._structs.set(structName, {
          name: structName,
          context: 'CONSTANTS',
          properties: properties,
        });
        break;
      default:
        (structContext       );
        throw new Error(`Detected an invalid struct context: ${structContext}`);
    }
  }

  getAllStructs()                         {
    return [...this._structs.values()];
  }

  getStruct(name        )          {
    return this._structs.get(name);
  }
}

module.exports = {
  StructCollector,
};
