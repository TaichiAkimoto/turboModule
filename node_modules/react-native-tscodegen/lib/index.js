"use strict";
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.generator = exports.typeScriptToCodeSchema = void 0;
var path = require("path");
var ts = require("typescript");
var ComponentParser_1 = require("./ComponentParser");
var ep = require("./ExportParser");
var NativeModuleParser_1 = require("./NativeModuleParser");
var TypeChecker_1 = require("./TypeChecker");
function messageChainToString(chain, indent) {
    var message = '';
    message += "" + indent + chain.messageText;
    if (chain.next !== undefined) {
        message += " {";
        var newIndent = indent + "  ";
        for (var _i = 0, _a = chain.next; _i < _a.length; _i++) {
            var subChain = _a[_i];
            message += "\r\n" + messageChainToString(subChain, newIndent);
        }
        message += indent + "\r\n}";
    }
    return message;
}
function errorToString(error) {
    var message = ts.DiagnosticCategory[error.category] + ":";
    if (error.source !== undefined) {
        message += "\r\n    source  : " + error.source;
    }
    if (error.file !== undefined) {
        message += "\r\n    file    : " + error.file.fileName;
    }
    if (typeof error.messageText === 'string') {
        message += "\r\n    message : " + error.messageText;
    }
    else {
        message += "\r\n    message {";
        message += "\r\n" + messageChainToString(error.messageText, '  ');
        message += "\r\n}";
    }
    return message;
}
function typeScriptToCodeSchema(fileName, moduleName, targetName) {
    var program = ts.createProgram([fileName], {
        strictNullChecks: true,
        skipLibCheck: true
    });
    var errors = ts.getPreEmitDiagnostics(program).filter(function (value) { return value.category === ts.DiagnosticCategory.Error; });
    if (errors.length > 0) {
        var errorMessage = 'Please ensure that the input TypeScript source file compiles.';
        for (var _i = 0, errors_1 = errors; _i < errors_1.length; _i++) {
            var error = errors_1[_i];
            errorMessage += "\r\n" + errorToString(error);
        }
        throw new Error(errorMessage);
    }
    var nativeModuleInfos = [];
    var componentInfos = [];
    var commandInfos = [];
    program.getSourceFiles().forEach(function (sourceFile) {
        if (path.basename(fileName) === path.basename(sourceFile.fileName)) {
            sourceFile.statements.forEach(function (node) {
                var currentNativeModuleInfo = ep.tryParseExportNativeModule(program, sourceFile, node);
                var currentComponentInfo = ep.tryParseExportComponent(program, sourceFile, node);
                var currentCommandInfo = ep.tryParseExportCommand(program, sourceFile, node);
                if (currentNativeModuleInfo !== undefined) {
                    nativeModuleInfos.push(currentNativeModuleInfo);
                }
                if (currentComponentInfo !== undefined) {
                    componentInfos.push(currentComponentInfo);
                }
                if (currentCommandInfo !== undefined) {
                    commandInfos.push(currentCommandInfo);
                }
            });
        }
    });
    if (nativeModuleInfos.length + componentInfos.length === 0) {
        throw new Error('Cannot find any component or native module.');
    }
    if (nativeModuleInfos.length + componentInfos.length > 1) {
        throw new Error('A TypeScript source file should only container either one component or one native module.');
    }
    if (nativeModuleInfos.length === 1) {
        if (commandInfos.length > 0) {
            throw new Error('Command list should not be exported in a TypeScript source file that exports a native module.');
        }
        // find out all type aliases in this file
        var aliases_1 = { aliases: {} };
        var knownAliases_1 = [];
        program.getSourceFiles().forEach(function (sourceFile) {
            if (path.basename(fileName) === path.basename(sourceFile.fileName)) {
                sourceFile.statements.forEach(function (node) {
                    if (ts.isTypeAliasDeclaration(node)) {
                        if (node.typeParameters === undefined || node.typeParameters.length === 0) {
                            var rnRawType = TypeChecker_1.typeToRNRawType(node.type, sourceFile, { allowObject: true, knownAliases: knownAliases_1 });
                            if (rnRawType.kind === 'Object') {
                                var aliasName = node.name.text;
                                aliases_1.aliases[aliasName] = rnRawType;
                                knownAliases_1.push(aliasName);
                            }
                        }
                    }
                });
            }
        });
        var info = nativeModuleInfos[0];
        var result = { modules: {} };
        result.modules[moduleName] = NativeModuleParser_1.processNativeModule(info, aliases_1);
        return result;
    }
    else {
        if (commandInfos.length > 1) {
            throw new Error('A TypeScript source file should not export more than one command list.');
        }
        var info = componentInfos[0];
        var result = { modules: {} };
        result.modules[info.name] = ComponentParser_1.processComponent(info, commandInfos[0]);
        return result;
    }
}
exports.typeScriptToCodeSchema = typeScriptToCodeSchema;
__exportStar(require("./CodegenSchema"), exports);
var rncodegen = require("./ExportRNCodegen");
var generator;
(function (generator) {
    generator.generate = rncodegen.generate;
})(generator = exports.generator || (exports.generator = {}));
//# sourceMappingURL=index.js.map